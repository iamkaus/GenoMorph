#include "regionGenerator.h"
#include <random>
#include <fstream>
#include <iostream>
#include <iomanip>

/**
 * @brief Constructs a RegionGenerator and seeds the RNG.
 * The RNG is seeded using the current system time to ensure different sequences on each run.
 */
RegionGenerator::RegionGenerator() {
    rng.seed(static_cast<unsigned>(time(0))); // Seed with system clock
}

/**
 * @brief Creates a new genomic region based on the current genome length and total genome length.
 * @param currentGenomeLength The length of the genome generated so far.
 * @param genomeLength The total desired length of the genome.
 * @return A RegionState struct representing the newly created region.
 * Throws std::invalid_argument if genomeLength is less than 100.
 * The function randomly decides the type of region (coding or non-coding),
 * its target GC or AT content, and its length based on predefined probabilities and distributions.
 */
RegionState RegionGenerator::createRegion(size_t currentGenomeLength, size_t genomeLength) {

    /**
     * @brief Validates the genome length.
     * Throws std::invalid_argument if genomeLength is less than 100.
     * This ensures that regions can be meaningfully generated.
    */
    if (genomeLength < 100) throw std::invalid_argument("Genome length must be at least 100");

    /**
     * @brief Randomly decides the region type and its properties.
     * Uses a uniform distribution to decide between coding and non-coding regions.
     * Non-coding regions are more probable (98%) and have lower GC content.
     * Coding regions are less probable (2%) and have higher GC content.
     * The lengths of regions are also determined by different distributions based on the type.
     * This stochastic approach simulates realistic genomic structures.
     * The function ensures that the generated region does not exceed the total genome length.
     * The start and end indices of the region are calculated based on the current genome length and the target length of the region.
     * The target_content is set to represent the fraction of G and C bases in the region.
     * The current_content and current_length_generated are initialized to zero for tracking progress during sequence generation.
     * The region_type is set to either "coding" or "non_coding" based on the random decision.
     * The function returns a fully initialized RegionState struct.
    */
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    double r = dist(rng);

    /**
     * @note DEBUG: The following print statement is for debugging purposes.
     * It outputs the random value used to decide the region type.
     */
    std::cout << r << std::endl;

    /**
     * @brief Initializes the RegionState struct with calculated properties.
     * Sets start_index, end_index, target_content, current_content, current_length_generated, target_length, and region_type.
     * Returns the initialized RegionState.
     * This struct is then used in the GenomeGenerator to guide the sequence generation process.
     * The use of random distributions ensures variability in the generated regions across different runs.
     * This variability is crucial for simulating realistic genomic sequences.
     * The function is designed to be efficient and straightforward, focusing on the essential properties needed for region generation.
     * The design allows for easy extension in the future, such as adding more region types or modifying the distributions used.
     * Overall, this function encapsulates the logic for creating diverse genomic regions in a clear and maintainable manner.
    */
    RegionState region;
    region.start_index = currentGenomeLength;
    region.current_content = 0.0;
    region.current_length_generated = 0;

    /**
     * @brief Decides region type and properties based on random value.
     * Non-coding regions (98% chance) have GC content between 0.35-0.45 and lengths 500-5000.
     * Coding regions (2% chance) have GC content between 0.45-0.75 and lengths 100-500.
     * Ensures the region does not exceed the total genome length.
     * Sets the end_index based on start_index and target_length.
     * Returns the fully initialized RegionState struct.
     * This approach simulates realistic genomic structures with variability in region types and properties.
     * 
     * @note The probability distribution here for deciding region type is arbitrary and flawed. The if statement is always true.
     * The value generated by dist(rng) is always less than 0.98, so the else block is never executed.
    */
    if (r < 0.98) { // 98% chance non-coding
        region.region_type = "non_coding";
        region.target_content = 0.35 + 0.1 * dist(rng); // GC fraction 0.35–0.45
        std::uniform_int_distribution<size_t> lenDist(500, 5000);
        region.target_length = std::min(lenDist(rng), genomeLength - currentGenomeLength);
    } else {
        region.region_type = "coding";
        region.target_content = 0.45 + 0.3 * dist(rng); // GC fraction 0.45–0.75
        std::uniform_int_distribution<size_t> lenDist(100, 500);
        region.target_length = std::min(lenDist(rng), genomeLength - currentGenomeLength);
    }

    /**
     * @brief Finalizes the region by setting the end_index.
     * Calculates end_index based on start_index and target_length.
     * Ensures the region fits within the total genome length.
     * Returns the initialized RegionState struct.
    */
    region.end_index = region.start_index + region.target_length - 1;
    return region;

}

/**
 * @brief Provides base probabilities based on the region type.
 * @param region The RegionState providing context for base probability determination.
 * @return An array of doubles representing the probabilities for A, T, C, and G respectively.
 * This function adjusts base probabilities to reflect the characteristics of the region.
 * For coding regions, higher GC content is favored, while non-coding regions favor AT content.
 * The returned probabilities can be used in base generation to ensure the sequence adheres to the region's properties.
 * The sum of the returned probabilities should ideally be 1.0.
 * This function is crucial for generating biologically relevant sequences.
 * The design allows for easy modification of base probabilities in the future.
 * Overall, this function encapsulates the logic for region-specific base probability determination.
 */

std::array<double, 4> RegionGenerator::regionBasedBaseProbabilities(const RegionState &region) {

    double GC_CONTENT = region.target_content;
    double AT_CONTENT = 1.0 - GC_CONTENT;

    double A_RATIO, T_RATIO, C_RATIO, G_RATIO;

    if ( region.region_type == "non_coding" ) {

        // Non-coding: G and C tend to be slightly asymmetric
        G_RATIO = 0.3;  // 30% of GC
        C_RATIO = 0.7;  // 70% of GC
        A_RATIO = 0.6;  // 60% of AT
        T_RATIO = 0.4;  // 40% of AT

    } else {

        // Coding: often more balanced GC, slightly biased A/T
        G_RATIO = 0.5;   // 30% of GC
        C_RATIO = 0.5;   // 70% of GC
        A_RATIO = 0.45;  // 60% of AT
        T_RATIO = 0.45;  // 40% of AT
    }

    double A_PROB = AT_CONTENT * A_RATIO;
    double T_PROB = AT_CONTENT * T_RATIO;
    double C_PROB = GC_CONTENT * C_RATIO;
    double G_PROB = GC_CONTENT * G_RATIO;

    double total = A_PROB + T_PROB + C_PROB + G_PROB;               // sums to 1.0

    // Normalize (just in case floating point rounding drifts)
    A_PROB /= total;
    T_PROB /= total;    
    C_PROB /= total;
    G_PROB /= total;

    return {A_PROB, T_PROB, C_PROB, G_PROB};
}

/**
 * --------------------------------------------------------------------------
 * 
 * 
 * The function print_region_probabilities(const RegionState& region) is not fundamentally necessary for the core functionality of the RegionGenerator class.
 * However, it can be a useful utility function for debugging and verification purposes.
 * It allows developers to easily inspect the base probabilities associated with a given region, ensuring that the probabilities align with the expected values based on the region's type and target content.
* This can help in validating that the region generation logic is functioning correctly and that the probabilities are being calculated as intended.
 * 
 * 
 * --------------------------------------------------------------------------
 */

 void RegionGenerator::print_region_probabilities(const RegionState& region) {
    auto probs = regionBasedBaseProbabilities(region);

    const std::string fileName = "results/probability.rtf";

    std::ofstream outfile(fileName);

    if (!outfile) {
        std::cerr << "Error: Could not open file " << fileName << std::endl;
        return;
    }

    static bool header_written = false;
    if (!header_written) {
        outfile << "{\\rtf1\\ansi\\deff0\n"
                << "{\\colortbl;\\red0\\green0\\blue255;\\red255\\green0\\blue0;}\n"
                << "\\b Region Probability Report \\b0\\line\n";
        header_written = true;
    }

    outfile << "\\line {\\cf1 [Region Info]}\\line\n"
            << "Type: " << region.region_type << "\\line\n"
            << "Target GC Content: " << std::fixed << std::setprecision(3) << region.target_content << "\\line\n"
            << "Target AT Content: " << std::fixed << std::setprecision(3) << (1.0 - region.target_content) << "\\line\n"
            << "Length: " << region.target_length << "\\line\n"
            << "{\\cf2 Probabilities -> A: " << probs[0]
            << " | T: " << probs[1]
            << " | G: " << probs[2]
            << " | C: " << probs[3] << "}\\line\n";

    outfile.close();

 }